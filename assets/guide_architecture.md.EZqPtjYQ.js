import{_ as i,c as a,o as e,ae as t}from"./chunks/framework.DfgEVOTW.js";const c=JSON.parse('{"title":"分层与语义（Architecture）","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture.md","filePath":"guide/architecture.md"}'),l={name:"guide/architecture.md"};function n(h,s,d,k,p,o){return e(),a("div",null,[...s[0]||(s[0]=[t('<h1 id="分层与语义-architecture" tabindex="-1">分层与语义（Architecture） <a class="header-anchor" href="#分层与语义-architecture" aria-label="Permalink to &quot;分层与语义（Architecture）&quot;">​</a></h1><p>本项目采用“读取 -&gt; 解析 -&gt; 转换 -&gt; 序列化”的分层架构：</p><ul><li><p>读取（Reader）</p><ul><li>文件到内部 <code>Table</code>：<code>src/utils/read.ts</code>（基于 <code>xlsx</code>，默认支持 <code>.xls</code>/<code>.xlsx</code>/<code>.csv</code>）。</li><li>产物仅包含原始单元格布局：<code>cols/data/getValue</code>。</li></ul></li><li><p>解析（Parse Layer）</p><ul><li>插件集合：<code>parsePlugins</code>（<code>src/pipeline/layers.ts</code>）。</li><li>包含：<code>rows/erows/mark/desc/schema</code>，将原始表头/类型标记解析为可用于后续步骤的语义信息。</li></ul></li><li><p>转换（Convert Layer）</p><ul><li>插件集合：<code>convertPlugins</code>（<code>src/pipeline/layers.ts</code>）。</li><li>负责根据 Schema 与数据行生成跨平台可读的结果 <code>{ tids, result, collisions }</code>。</li></ul></li><li><p>序列化（Serializers）</p><ul><li>将转换结果输出为不同目标格式：<code>json/js/ts/ts-interface</code> 等。</li><li>稳定性：对 <code>result</code> 的 key 做排序，保证产物稳定。</li></ul></li></ul><h2 id="数据流水线细节" tabindex="-1">数据流水线细节 <a class="header-anchor" href="#数据流水线细节" aria-label="Permalink to &quot;数据流水线细节&quot;">​</a></h2><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Excel Sheet</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ▼</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">readAndTranslate (src/utils/read.ts)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │  └─ 构造 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`Table`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">：{ cols, data, getValue }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ▼</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Parse Plugins (rows → erows → mark → desc → schema)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │  └─ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`tableSchema`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 调用 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`@khgame/schema.parseSchema`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ▼</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Convert Plugins (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`tableConvert`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │  ├─ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`exportJson`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> + </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`SchemaConvertor`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 校验行数据</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │  ├─ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`buildSchemaModel`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 生成 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`TypeNode`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 抽象</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │  └─ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`normalizeValue`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> / </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">`normalizePrimitive`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 归一化结果</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ▼</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Serializers (json/js/ts/ts-interface/...)</span></span></code></pre></div><ul><li>Schema 构建：<code>buildSchemaModel</code> (<code>src/serializer/core/schemaModel.ts</code>) 将 SDM/TDM 节点翻译成统一的 <code>TypeNode</code>。<code>convertTNode</code> 会把 <code>int</code>/<code>uint</code> 等数值类型折叠成 <code>PrimitiveType { kind: &#39;primitive&#39;, name: &#39;number&#39; }</code>，并依据 <code>node.rawName</code> 组装 <code>hintMeta</code>（strategyHint/sourceAlias/flavor），为溢出防护、大整数精度处理乃至自定义语义扩展提供锚点。<code>test/unit/schemaModel.test.ts</code> 与 <code>test/unit/hintMetadata.test.ts</code> 持续校验该接线。</li><li>数值归一化：<code>normalizePrimitive</code> (<code>src/plugin/convert.ts</code>) 读取 <code>node.hintMeta.strategyHint</code>。约定 <code>&#39;int&#39;</code> 时执行安全整数检验，不安全就抛错；<code>&#39;bigint&#39;</code> 时统一输出字符串以保留精度。它仍是所有数值校验的最终关卡，若未启用 hintmeta 则回退到默认逻辑；<code>test/unit/convert.hintmeta.test.ts</code> 演示了字符串化与溢出报错路径。</li><li>类型别名：所有 Excel 类型标记先通过 <code>@khgame/schema</code> 的别名表归一（<code>node_modules/@khgame/schema/lib/constant.js</code>）。例如 <code>int8/int16/int32/int64/long</code> 都映射到主类型 <code>int</code>，<code>uint64/ulong</code> 映射到 <code>uint</code>。</li><li>枚举 alias 扩展：context 枚举现已支持“字面量 + 引用”混合写法。枚举值既可以是字符串/数组（兼容旧版对象映射），也可以是包含 <code>ref</code> 字段的对象（或在对象风格枚举中通过 <code>__refs</code>/<code>$refs</code> 追加）。<code>ref</code> 接受 <code>table#field</code> 或 <code>{ table, field }</code>，并可指定 <code>filter</code>、<code>nameField</code>、<code>valueField</code>、<code>descriptionField</code>、<code>transform/prefix/suffix</code> 等参数。加载阶段会读取目标表的 alias 列（经 <code>tableConvert</code> 校验）并展开为枚举项，生成的枚举随 <code>enum&lt;...&gt;</code> 校验器自动保持与 alias 源数据一致。</li></ul><h2 id="协议-protocol" tabindex="-1">协议（Protocol） <a class="header-anchor" href="#协议-protocol" aria-label="Permalink to &quot;协议（Protocol）&quot;">​</a></h2><p>为便于跨平台消费和版本治理，定义了可选的数据协议头（<code>src/core/protocol.ts</code>）：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TablesArtifact</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  protocol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;khgame.tables&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">version</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fileName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sheetName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  convert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tids</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">collisions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>默认 <code>json/js/ts/ts-interface</code> 不改变现有格式；如需带协议头，使用 <code>jsonxSerializer</code>（实验性）。</p><h2 id="扩展点" tabindex="-1">扩展点 <a class="header-anchor" href="#扩展点" aria-label="Permalink to &quot;扩展点&quot;">​</a></h2><ul><li>自定义 Reader：替换/拓展 <code>readWorkBook/translateWorkBook</code>（Google Sheets / 自定义 API 等来源）。</li><li>自定义 Parse/Convert 插件：与 <code>Table</code> 结构解耦，按需插拔。</li><li>自定义 Serializer：声明所需插件，产出任意目标语言/格式。</li></ul>',12)])])}const E=i(l,[["render",n]]);export{c as __pageData,E as default};
