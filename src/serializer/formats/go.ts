import { tableSchema, tableConvert } from '../../plugin'
import type { Serializer } from '../../types'
import {
  buildSchemaModel,
  isEmptyArray,
  isUnion,
  type ArrayType,
  type LiteralType,
  type ObjectField,
  type ObjectType,
  type PrimitiveType,
  type SchemaModel,
  type TupleType,
  type TypeNode,
  type UnionType,
  type EnumReferenceType
} from '../core/schemaModel'

export const goSerializer: Serializer = {
  plugins: [tableSchema, tableConvert],
  file: (data, fileName, _imports, context) => {
    const typeName = makeExportedName(fileName, 'Record')
    const model: SchemaModel = buildSchemaModel((data as any).schema, (data as any).descLine, (data as any).markCols, context)
    const tidMeta = (data as any).convert?.meta
    const tidAware = Array.isArray(tidMeta?.idSegments) && tidMeta.idSegments.length > 0
    const tidDefinitions = tidAware ? renderTIDDefinitions(typeName) + '\n' : ''
    const goType = renderRootType(typeName, model, tidAware)

    return `// Code generated by tables. DO NOT EDIT.\n\npackage tables\n\n${tidDefinitions}${goType}\n`
  }
}

function renderTIDDefinitions(typeName: string): string {
  const tidName = `${typeName}TID`
  const ctorName = `New${typeName}TID`
  const mapName = `${typeName}Map`
  return `type ${tidName} string\n\nfunc ${ctorName}(value string) ${tidName} {\n  return ${tidName}(value)\n}\n\ntype ${mapName} map[${tidName}]${typeName}\n`
}

function renderRootType(typeName: string, model: SchemaModel, tidAware: boolean): string {
  if (model.kind === 'object') {
    const structBody = renderObject(model, 0)
    const rendered = `type ${typeName} ${structBody}`
    return tidAware ? injectTidField(rendered, typeName) : rendered
  }
  const typeExpr = renderTypeNode(model, 0)
  return `type ${typeName} ${typeExpr}`
}

function renderTypeNode(node: TypeNode, depth: number): string {
  switch (node.kind) {
    case 'primitive':
      return renderPrimitive(node)
    case 'literal':
      return renderLiteral(node)
    case 'enum':
      return renderEnum(node)
    case 'object':
      return renderObject(node, depth)
    case 'array':
      return renderArray(node, depth)
    case 'tuple':
      return renderTuple(node, depth)
    case 'union':
      return renderUnion(node, depth)
    default:
      return 'interface{}'
  }
}

function renderPrimitive(node: PrimitiveType): string {
  switch (node.name) {
    case 'string':
      return 'string'
    case 'number':
      return 'float64'
    case 'boolean':
      return 'bool'
    case 'undefined':
    case 'any':
    default:
      return 'interface{}'
  }
}

function renderLiteral(node: LiteralType): string {
  const value = node.value
  if (typeof value === 'string') return 'string'
  if (typeof value === 'number') return 'float64'
  if (typeof value === 'boolean') return 'bool'
  return 'interface{}'
}

function renderEnum(_node: EnumReferenceType): string {
  return 'string'
}

function renderObject(node: ObjectType, depth: number): string {
  const fields = node.fields || []
  if (fields.length === 0) {
    return 'struct{}'
  }
  const indent = indentOf(depth + 1)
  const closingIndent = indentOf(depth)
  const lines = fields.map(field => `${indent}${renderStructField(field, depth + 1)}`)
  return `struct {\n${lines.join('\n')}\n${closingIndent}}`
}

function renderStructField(field: ObjectField, depth: number): string {
  const { base, optional } = unwrapOptional(field.type)
  let typeExpr = renderTypeNode(base, depth)

  const shouldPointer = optional && typeExpr !== 'interface{}'
  if (shouldPointer) {
    typeExpr = pointerize(typeExpr)
  }

  const originalName = field.name || 'field'
  const fieldName = makeExportedName(originalName, 'Field')
  const tagName = originalName
  const tagSuffix = optional ? ',omitempty' : ''
  const tag = `json:"${tagName}${tagSuffix}"`
  return `${fieldName} ${typeExpr} \`${tag}\``
}

function injectTidField(goType: string, typeName: string): string {
  const marker = `type ${typeName} struct {\n`
  const index = goType.indexOf(marker)
  if (index < 0) return goType
  const tidField = `  TID ${typeName}TID \`json:"_tid"\`\n`
  return goType.replace(marker, `${marker}${tidField}`)
}

function renderArray(node: ArrayType, depth: number): string {
  if (isEmptyArray(node)) {
    return '[]interface{}'
  }
  const element = node.element ?? ({ kind: 'primitive', name: 'any' } as PrimitiveType)
  const rendered = renderTypeNode(element, depth + 1)
  return `[]${rendered}`
}

function renderTuple(node: TupleType, depth: number): string {
  const elements = node.elements || []
  if (elements.length === 0) {
    return '[]interface{}'
  }
  const rendered = elements.map(element => renderTypeNode(element, depth + 1))
  const unique = Array.from(new Set(rendered))
  if (unique.length === 1) {
    return `[]${unique[0]}`
  }
  return '[]interface{}'
}

function renderUnion(node: UnionType, depth: number): string {
  const variants = node.variants || []
  const filtered = variants.filter(variant => !isUndefinedNode(variant))
  if (filtered.length === 0) {
    return 'interface{}'
  }
  if (filtered.length === 1) {
    return renderTypeNode(filtered[0], depth)
  }
  if (filtered.every(isStringLike)) {
    return 'string'
  }
  if (filtered.every(isNumberLike)) {
    return 'float64'
  }
  if (filtered.every(isBooleanLike)) {
    return 'bool'
  }
  return 'interface{}'
}

function unwrapOptional(node: TypeNode): { base: TypeNode; optional: boolean } {
  if (node.kind === 'union') {
    const filtered = node.variants.filter(variant => !isUndefinedNode(variant))
    const optional = filtered.length !== node.variants.length
    if (optional && filtered.length === 1) {
      return { base: filtered[0], optional: true }
    }
  }
  return { base: node, optional: false }
}

function isUndefinedNode(node: TypeNode): boolean {
  return node.kind === 'primitive' && node.name === 'undefined'
}

function pointerize(typeExpr: string): string {
  if (typeExpr.startsWith('*')) return typeExpr
  return `*${typeExpr}`
}

function isStringLike(node: TypeNode): boolean {
  if (node.kind === 'primitive' && node.name === 'string') return true
  if (node.kind === 'literal' && typeof node.value === 'string') return true
  if (node.kind === 'enum') return true
  return false
}

function isNumberLike(node: TypeNode): boolean {
  if (node.kind === 'primitive' && node.name === 'number') return true
  if (node.kind === 'literal' && typeof node.value === 'number') return true
  return false
}

function isBooleanLike(node: TypeNode): boolean {
  if (node.kind === 'primitive' && node.name === 'boolean') return true
  if (node.kind === 'literal' && typeof node.value === 'boolean') return true
  return false
}

function indentOf(depth: number): string {
  return '  '.repeat(depth)
}

function makeExportedName(source: string, fallback: string): string {
  const spaced = (source || '')
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
    .replace(/[^A-Za-z0-9]+/g, ' ')
    .trim()
  if (!spaced) return fallback
  const parts = spaced.split(/\s+/).filter(Boolean)
  if (parts.length === 0) return fallback
  return parts
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}
