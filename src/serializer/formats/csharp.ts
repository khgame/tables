import { tableSchema, tableConvert } from '../../plugin'
import { makeCamelName } from '../../utils/names'
import type { Serializer } from '../../types'
import {
  buildSchemaModel,
  isEmptyArray,
  type LiteralType,
  type ObjectField,
  type ObjectType,
  type PrimitiveType,
  type SchemaModel,
  type TupleType,
  type TypeNode,
  type UnionType
} from '../core/schemaModel'

interface TypeInfo {
  typeName: string
  isValueType: boolean
  isReferenceType: boolean
}

export const csharpSerializer: Serializer = {
  plugins: [tableSchema, tableConvert],
  file: (data, fileName, _imports, context) => {
    const model: SchemaModel = buildSchemaModel((data as any).schema, (data as any).descLine, (data as any).markCols, context)
    const rootName = makeClassName([fileName], 'Record')
    const tidMeta = (data as any).convert?.meta
    const tidAware = Array.isArray(tidMeta?.idSegments) && tidMeta.idSegments.length > 0

    const declarations = new Map<string, string>()
    const classNames = new Map<string, string>()
    const seenPaths = new Set<string>()
    const uses = new Set<string>(['System'])

    const rootClass = renderClass(
      model,
      [rootName],
      declarations,
      classNames,
      seenPaths,
      uses,
      tidAware ? `${rootName}TID` : undefined
    )

    const nested = Array.from(declarations.values())

    const usingLines: string[] = []
    if (Array.from(declarations.values()).some(def => def.includes('List<')) || rootClass.includes('List<')) {
      uses.add('System.Collections.Generic')
    }
    uses.add('System.Text.Json.Serialization')
    if (tidAware) {
      uses.add('System.Text.Json')
    }

    usingLines.push(...Array.from(uses).sort().map(u => `using ${u};`))

    const bodyLines = [
      ...(tidAware ? [renderTidDefinitions(rootName)] : []),
      rootClass,
      ...nested.filter(line => line !== rootClass)
    ]

    return `// Code generated by tables. DO NOT EDIT.\n#nullable enable\n${usingLines.join('\n')}\n\nnamespace Tables\n{\n${indentLines(bodyLines.join('\n\n'), 1)}\n}`
  }
}

function renderTidDefinitions(rootName: string): string {
  const tidName = `${rootName}TID`
  const converterName = `${tidName}Converter`
  return `[JsonConverter(typeof(${converterName}))]
public readonly record struct ${tidName}(string Value);

public sealed class ${converterName} : JsonConverter<${tidName}>
{
    public override ${tidName} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        => new ${tidName}(reader.GetString() ?? string.Empty);

    public override void Write(Utf8JsonWriter writer, ${tidName} value, JsonSerializerOptions options)
        => writer.WriteStringValue(value.Value);
}

public static class ${tidName}Extensions
{
    public static ${tidName} To${tidName}(this string value) => new ${tidName}(value);
}
`
}

function renderClass(
  model: SchemaModel,
  path: string[],
  declarations: Map<string, string>,
  classNames: Map<string, string>,
  seenPaths: Set<string>,
  uses: Set<string>,
  rootTid?: string
): string {
  const className = makeClassName(path, 'Record')
  const key = path.join('>')
  if (seenPaths.has(key)) {
    return declarations.get(className) ?? `public class ${className} { }`
  }

  const fields = extractObjectFields(model)
  const properties: string[] = []
  const childDeclarations: string[] = []

  if (rootTid && path.length === 1) {
    const tidProperty = `[JsonPropertyName("_tid")]\n${indentLines(`public ${rootTid} TID { get; set; }`, 1)}`
    properties.push(tidProperty)
  }

  for (const field of fields) {
    const propertyName = makePropertyName(field.name)
    const { typeName } = renderPropertyType(field.type, path.concat([propertyName]), declarations, classNames, uses)

    const jsonAttr = `[JsonPropertyName("${field.name}")]`
    properties.push(`${jsonAttr}\n${indentLines(`public ${typeName} ${propertyName} { get; set; }`, 1)}`)
  }

  const classBody = properties.length > 0 ? properties.join('\n\n') : ''
  const classDefinition = `public class ${className}\n{${classBody ? `\n${classBody}\n` : '\n'} }`

  declarations.set(className, classDefinition)
  seenPaths.add(key)
  return classDefinition
}

function renderPropertyType(
  node: TypeNode,
  path: string[],
  declarations: Map<string, string>,
  classNames: Map<string, string>,
  uses: Set<string>
): { typeName: string } {
  const { base, optional } = unwrapOptional(node)
  const info = renderTypeInfo(base, path, declarations, classNames, uses)
  let typeName = info.typeName
  if (optional) {
    if (info.isValueType) {
      typeName = `${typeName}?`
    } else {
      typeName = `${typeName}?`
    }
  }
  return { typeName }
}

function renderTypeInfo(
  node: TypeNode,
  path: string[],
  declarations: Map<string, string>,
  classNames: Map<string, string>,
  uses: Set<string>
): TypeInfo {
  switch (node.kind) {
    case 'primitive':
      return renderPrimitiveType(node)
    case 'literal':
      return renderLiteralType(node)
    case 'enum':
      return { typeName: 'string', isValueType: false, isReferenceType: true }
    case 'object':
      return renderObjectType(node, path, declarations, classNames, uses)
    case 'array':
      return renderArrayType(node, path, declarations, classNames, uses)
    case 'tuple':
      return renderTupleType(node, path, declarations, classNames, uses)
    case 'union':
      return renderUnionType(node, path, declarations, classNames, uses)
    default:
      return { typeName: 'object', isValueType: false, isReferenceType: true }
  }
}

function renderPrimitiveType(node: PrimitiveType): TypeInfo {
  switch (node.name) {
    case 'string':
      return { typeName: 'string', isValueType: false, isReferenceType: true }
    case 'number':
      return { typeName: 'double', isValueType: true, isReferenceType: false }
    case 'boolean':
      return { typeName: 'bool', isValueType: true, isReferenceType: false }
    case 'undefined':
    case 'any':
    default:
      return { typeName: 'object', isValueType: false, isReferenceType: true }
  }
}

function renderLiteralType(node: LiteralType): TypeInfo {
  switch (typeof node.value) {
    case 'string':
      return { typeName: 'string', isValueType: false, isReferenceType: true }
    case 'number':
      return { typeName: 'double', isValueType: true, isReferenceType: false }
    case 'boolean':
      return { typeName: 'bool', isValueType: true, isReferenceType: false }
    default:
      return { typeName: 'object', isValueType: false, isReferenceType: true }
  }
}

function renderObjectType(
  node: ObjectType,
  path: string[],
  declarations: Map<string, string>,
  classNames: Map<string, string>,
  uses: Set<string>
): TypeInfo {
  const className = makeClassName(path, 'Record')
  if (!classNames.has(path.join('>'))) {
    classNames.set(path.join('>'), className)
    const properties: string[] = []
    for (const field of node.fields || []) {
      const propertyName = makePropertyName(field.name)
      const { typeName } = renderPropertyType(field.type, path.concat([propertyName]), declarations, classNames, uses)
      const jsonAttr = `[JsonPropertyName("${field.name}")]`
      properties.push(`${jsonAttr}\n${indentLines(`public ${typeName} ${propertyName} { get; set; }`, 1)}`)
    }
    const classBody = properties.length > 0 ? `\n${properties.join('\n\n')}\n` : '\n'
    declarations.set(className, `public class ${className}\n{${classBody} }`)
  }
  return { typeName: className, isValueType: false, isReferenceType: true }
}

function renderArrayType(
  node: ArrayType,
  path: string[],
  declarations: Map<string, string>,
  classNames: Map<string, string>,
  uses: Set<string>
): TypeInfo {
  uses.add('System.Collections.Generic')
  if (isEmptyArray(node)) {
    return { typeName: 'List<object>', isValueType: false, isReferenceType: true }
  }
  const element = node.element ?? { kind: 'primitive', name: 'any' } as TypeNode
  const info = renderTypeInfo(element, path.concat(['Item']), declarations, classNames, uses)
  return { typeName: `List<${info.typeName}>`, isValueType: false, isReferenceType: true }
}

function renderTupleType(
  node: TupleType,
  path: string[],
  declarations: Map<string, string>,
  classNames: Map<string, string>,
  uses: Set<string>
): TypeInfo {
  uses.add('System.Collections.Generic')
  const elements = node.elements || []
  if (elements.length === 0) {
    return { typeName: 'List<object>', isValueType: false, isReferenceType: true }
  }
  const rendered = elements.map((element, index) => renderTypeInfo(element, path.concat([`Item${index}`]), declarations, classNames, uses))
  const unique = Array.from(new Set(rendered.map(r => r.typeName)))
  if (unique.length === 1) {
    return { typeName: `List<${unique[0]}>`, isValueType: false, isReferenceType: true }
  }
  return { typeName: 'List<object>', isValueType: false, isReferenceType: true }
}

function renderUnionType(
  node: UnionType,
  path: string[],
  declarations: Map<string, string>,
  classNames: Map<string, string>,
  uses: Set<string>
): TypeInfo {
  const variants = node.variants || []
  const filtered = variants.filter(variant => !isUndefinedNode(variant))
  if (filtered.length === 0) {
    return { typeName: 'object', isValueType: false, isReferenceType: true }
  }
  if (filtered.length === 1) {
    return renderTypeInfo(filtered[0], path, declarations, classNames, uses)
  }
  if (filtered.every(isStringLike)) {
    return { typeName: 'string', isValueType: false, isReferenceType: true }
  }
  if (filtered.every(isNumberLike)) {
    return { typeName: 'double', isValueType: true, isReferenceType: false }
  }
  if (filtered.every(isBooleanLike)) {
    return { typeName: 'bool', isValueType: true, isReferenceType: false }
  }
  return { typeName: 'object', isValueType: false, isReferenceType: true }
}

function unwrapOptional(node: TypeNode): { base: TypeNode; optional: boolean } {
  if (node.kind === 'union') {
    const filtered = node.variants.filter(variant => !isUndefinedNode(variant))
    const optional = filtered.length !== node.variants.length
    if (optional && filtered.length === 1) {
      return { base: filtered[0], optional: true }
    }
    return { base: { kind: 'union', variants: filtered }, optional }
  }
  return { base: node, optional: false }
}

function isUndefinedNode(node: TypeNode): boolean {
  return node.kind === 'primitive' && node.name === 'undefined'
}

function isStringLike(node: TypeNode): boolean {
  if (node.kind === 'primitive' && node.name === 'string') return true
  if (node.kind === 'literal' && typeof node.value === 'string') return true
  if (node.kind === 'enum') return true
  return false
}

function isNumberLike(node: TypeNode): boolean {
  if (node.kind === 'primitive' && node.name === 'number') return true
  if (node.kind === 'literal' && typeof node.value === 'number') return true
  return false
}

function isBooleanLike(node: TypeNode): boolean {
  if (node.kind === 'primitive' && node.name === 'boolean') return true
  if (node.kind === 'literal' && typeof node.value === 'boolean') return true
  return false
}

function extractObjectFields(model: SchemaModel): ObjectField[] {
  if (model.kind === 'object') {
    return model.fields || []
  }
  return []
}

function makeClassName(segments: string[], fallback: string): string {
  const mapped = segments
    .map(segment => makeClassSegment(segment))
    .filter(Boolean)
  const name = mapped.join('')
  return name.length > 0 ? name : fallback
}

function makeClassSegment(source: string): string {
  const raw = (source || '').trim()
  if (!raw) return ''
  const sanitized = raw.replace(/[^A-Za-z0-9\s._-]+/g, ' ')
  const hasSeparator = /[\s._-]/.test(sanitized)
  let candidate = hasSeparator ? makeCamelName(sanitized) : sanitized
  candidate = candidate.replace(/[^A-Za-z0-9]/g, '')
  if (!candidate) return ''
  candidate = candidate.charAt(0).toUpperCase() + candidate.slice(1)
  if (!/[A-Za-z]/.test(candidate.charAt(0))) {
    return ''
  }
  return candidate
}

function makePropertyName(source: string): string {
  const raw = (source || '').trim()
  const sanitized = raw.replace(/[^A-Za-z0-9\s._-]+/g, ' ')
  let candidate = /[\s._-]/.test(sanitized)
    ? makeCamelName(sanitized)
    : sanitized

  candidate = candidate.replace(/[^A-Za-z0-9]/g, '')
  if (!candidate) {
    return 'Field'
  }

  candidate = candidate.charAt(0).toUpperCase() + candidate.slice(1)
  if (!/[A-Za-z]/.test(candidate.charAt(0))) {
    return `Field${candidate}`
  }
  return candidate
}

function indentLines(text: string, level: number): string {
  const indent = '    '.repeat(level)
  return text
    .split('\n')
    .map(line => (line.length ? `${indent}${line}` : line))
    .join('\n')
}
